/**
 * 列表组件
 * 列表组件是一个支持NxM矩阵式排列的组件，其内部的项（item）是通过创建另一个界面源实现的
 *  -- 项数据基类：UIListItemData （此外系统会自动创建每个界面作为项数据类-ListItem_?，请查阅system/UIRuntime.ts）
 *     项数据类会自动根据控件创建相应的属性，以便填充后自动呈现出该数值或字符串（以及图片地址等）
 *     项数据映射值参考：
 *     UIBitmap -> string-图片地址
 *     UIString -> string-文本
 *     UIVariable -> number-数值变量ID
 *     UIAvatar -> number-行走图ID
 *     UIStandAvatar -> number-立绘ID
 *     UIAnimation -> number-动画ID
 *     UIInput -> string-默认文本
 *     UICheckBox -> boolean-选中状态
 *     UISwitch -> number-开关ID
 *     UITabBox -> string-项（如aa,bb,cc）
 *     UISlider -> number-值
 *     UIGUI -> number-界面ID
 *     UIList -> UIListItemData[]-项数据
 * 
 * 相关事件：
 *  EventObject.CHANGE 当改变状态时派发  onChange(state:number) state=0 表示selectedIndex改变，否则是overIndex
 *  EventObject.LOADED 加载完成时候事件
 *  UIList.OPEN_STATE_CHANGE 打开状态发生改变时
 *  UIList.ITEM_CLICK 点击确认项
 *  UIList.EVENT_FOCUS_CHANGE 【EventUtils事件】当焦点更改时派发的事件
 *  UIList.ITEM_CREATE 创建项时
 * 
 * 使用方法：
 *  // 列表方式添加数据
 *  var a = new UIList();
 *  a.overImageURL = "asset/image/picture/control/uilistover.png";
 *  a.selectImageURL = "asset/image/picture/control/uilistselect.png";
 *  a.itemModelGUI = 8; // 使用指定的界面ID来创建项，如果需要指定类，请使用 itemModelClass
 *  stage.addChild(a);
 *  var dArr = [];
 *  for(var i=0;i<10;i++){
 *     var d:ListItem_8 = new ListItem_8();
 *     d.pic = "asset/image/a.jpg"; // 假设8号界面存在名为pic的控件
 *     d.txt = "kds"; // 假设8号界面存在名为txt的文本
 *     d.战斗力 = 5; // 假设8号界面存在名为战斗力的数值变量控件，这里绑定5号变量 
 *     dArr.push(d);
 *  }
 *  a.items = dArr;
 * 
 *  // 树方式添加数据：在设置a.items前就决定好数据的父子节点关系：
 *  var child = new ListItem_8();
 *  child.pic = "asset/image/a.jpg";
 *  child.txt = "kdsChild";
 *  child.战斗力 = 5;
 *  dArr[2].push(child);
 * 
 * // 事件监听示例
 * a.on(EventObject.CHANGE,this,this.onChange);
 * 
 * Created by 黑暗之神KDS on 2019-07-09 15:04:27.
 */
class UIList extends UIRoot {
    /**
     * 事件：当焦点更改时派发的事件 onFocusChange(lastFocus:UIList,currentFocus:UIList);
     * <code>
     * // lastFocus - 表示上次的焦点列表
     * // currentFocus - 表示此次的焦点列表
     * EventUtils.addEventListener(UIList,UIList.EVENT_FOCUS_CHANGE,Callback.New((lastFocus:UIList,currentFocus:UIList)=>{
     *    // to do
     * },this));
     * </code>
     */
    static EVENT_FOCUS_CHANGE: string;
    /**
     * 事件：打开状态发生改变时 onChange(ui,data)
     * <code>
     * uiList.on(UIList.OPEN_STATE_CHANGE,this,this.onOpenStateChange);
     * </code>
     */
    static OPEN_STATE_CHANGE: string;
    /**
     * 事件：点击确认项（已选中该项时再点击则派发事件/或ENTER键）
     * <code>
     * uiList.on(UIList.ITEM_CLICK,this,this.onItemClick);
     * </code>
     */
    static ITEM_CLICK: string;
    /**
     * 事件：创建项时 onItemCreate(ui: UIRoot, data: UIListItemData,index:number)
     * <code>
     * uiList.on(UIList.ITEM_CREATE,this,this.onItemCreate);
     * </code>
     */
    static ITEM_CREATE: string;
    /**
     * 按键-向上移动 开启键盘支持后的默认快捷键，支持修改
     */
    static KEY_UP: number[] = [Keyboard.UP];
    /**
     * 按键-向下移动 开启键盘支持后的默认快捷键，支持修改
     */
    static KEY_DOWN: number[] = [Keyboard.DOWN];
    /**
     * 按键-向左移动 开启键盘支持后的默认快捷键，支持修改
     */
    static KEY_LEFT: number[] = [Keyboard.LEFT];
    /**
     * 按键-向右移动 开启键盘支持后的默认快捷键，支持修改
     */
    static KEY_RIGHT: number[] = [Keyboard.RIGHT];
    /**
     * 按键-确定 开启键盘支持后的默认快捷键，支持修改
     */
    static KEY_ENTER: number[] = [Keyboard.ENTER, Keyboard.SPACE];
    /**
     * 开启键盘（手柄）支持：仅能操作当前焦点的UIList
     */
    static KEY_BOARD_ENABLED: boolean;
    /**
     * 开启单一焦点系统（焦点在指定的List上才可以操作，否则默认是无法操作的状态）
     * 通过设置UIList.focus来激活指定的列表以便操作
     */
    static SINGLE_FOCUS_MODE: boolean;
    /**
     * 设置List焦点：
     * -- 只有设置了焦点的按键才有效
     * -- 如果是单一焦点系统的话同一时间内只允许一个List启用
     */
    static focus: UIList;
    /**
     * 模拟按键按下：仅能操作当前焦点的UIList
     * @param keyCode 对应键位 KEY_UP/KEY_DOWN/KEY_LEFT/KEY_RIGHT/KEY_ENTER
     */
    static setKeyDown(keyCode: number): void {

    }
    /**
     * 鼠标悬停则作为选中效果（默认是悬停效果）
     */
    overSelectMode: boolean = false;
    /**
     * 创建ITEM时回调 onCreateItem(ui: UIRoot, data: UIListItemData,index:number)
     */
    onCreateItem: Callback;
    /**
     * 子项缩进
     */
    subitemIndentation: number = 20;

    /**
     * 是否允许选择
     */
    selectEnable: boolean = true;
    /**
     *  列数
     */
    repeatX: number = 1;
    /**
     * 横向间隔
     */
    spaceX: number = 2;
    /**
     * 重向间隔
     */
    spaceY: number = 20;
    /**
     * 项宽度
     */
    itemWidth: number = 200;
    /**
     * 项高度
     */
    itemHeight: number = 50;
    /**
     * 光标悬停时的效果图片
     */
    overImageURL: string;
    /**
     * 光标悬停时的对象：获取对象有利于自己追加一些额外的效果逻辑
     */
    overImage: UIBitmap;
    /**
     * 选中项的效果图片
     */
    selectImageURL: string;
    /**
     * 选中项的效果图片对象：获取对象有利于自己追加一些额外的效果逻辑
     */
    selectedImage: UIBitmap;
	/**
     * 光标在项上面时的效果图片的九宫格
     * 九宫格设置：上边距、右边距、下边距、左边距、是否平铺（1表示平铺）
     * 让素材不再简单拉伸，而是根据九宫格方式进行拉伸
     */
    overImageGrid9: string = "0,0,0,0,0";
    /**
    * 选中项的效果图片的九宫格
    * 九宫格设置：上边距、右边距、下边距、左边距、是否平铺（1表示平铺）
    * 让素材不再简单拉伸，而是根据九宫格方式进行拉伸
    */
    selectImageGrid9: string = "0,0,0,0,0";
    /**
     * 选中项时效果图片的透明度
     */
    selectedImageAlpha: number = 0.5;
    /**
     *  光标在项上面时的效果图片的透明度
     */
    overImageAlpha: number = 0.5;
    /**
     * 选中项时效果图片是否在上层显示（盖住项）
     */
    selectedImageOnTop: boolean = true;
    /**
     * 光标在项上面时的效果图片是否在上层显示（盖住项）
     */
    overImageOnTop: boolean = true;
    /**
     * 项的类设定
     */
    itemModelClass: any;
    /**
     * 项对应的界面ID
     */
    itemModelGUI: number;
    /**
     * 所有项数据
     */
    items: UIListItemData[];
    /**
     * 获取全部项对应的显示对象
     * 如果更新了项数据则显示对象也会被替换成新的，若需要记录该显示对象请谨慎使用
     */
    itemSprites: Sprite[];
    /**
     * 列表的数据总个数。
     */
    get length(): number {
        return null;
    };
    /**
     * 选中项，根据指定的数据
     * @return [UIListItemData] 
     */
    selectedItem: UIListItemData;
    /**
     * 选中项，根据索引（即所在数据组的位置，数据组包括未打开的隐藏树节点）
     * @return [number] 
     */
    selectedIndex: number = -1;
    /**
     * 选中项，根据索引，不派发EventObject.CHANGE事件
     * @param v 选中项
     */
    setSelectedIndexForce(v: number): void {

    }
    /**
     * 悬停项，根据索引（即所在数据组的位置，数据组包括未打开的隐藏树节点）
     */
    overIndex: number = -1;
    /**
     * 悬停项，根据索引，不派发EventObject.CHANGE事件
     * @param v 悬停项
     */
    setOverIndexForce(v: number): void {

    }
    /**
     * 滚动到指定行：如果该项显示对象在完全显示中时则忽略滚动
     * @param index 指定的索引
     * @param ignoreAlreadyInVisible [可选] 默认值=true 忽略已
     * @param tween [可选] 默认值=false 是否缓动
     * @param duration [可选] 默认值=0 持续时间
     * @param ease [可选] 默认值=null 缓动方法
     * @param complete [可选] 默认值=null 当缓动完毕时回调
     */
    scrollTo(index: number, ignoreAlreadyInVisible: boolean = true, tween: boolean = false, duration: number = 0, ease: Function = null, complete: Callback = null): void {

    }
    /**
     * 替换数据刷新显示，同时会触发 onCreateItem 函数
     * @param itemData 新数据
     * @param index 需要替换的items索引
     */
    replaceItem(itemData: UIListItemData, index: number): void {

    }
    /**
     * 获取项的显示对象
     * @param index 索引
     * @return [UIRoot] 
     */
    getItemUI(index: number): UIRoot {
        return null;
    }
}
